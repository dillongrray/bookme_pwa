/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';
import { getActionsFromQueue, removeActionFromQueue } from './util/indexedDBHelper';
import { baseQueueData, queueData, queueStatus } from './util/interfaces';
import axios from 'axios';

declare const self: ServiceWorkerGlobalScope;



clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL  + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', async(event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.source && event.data && event.data.type === 'INVALIDATE_CACHE') {
    const { cacheNames } = event.data.payload;

    // Delete the specified cache
    for (let name of cacheNames) {
      await caches.delete(name);
    }

    // Optionally, you can inform the client that the cache has been invalidated.
    event.source.postMessage({
      type: 'CACHE_INVALIDATED'
    });
  }

  if (event.source && event.data && event.data.type === 'QUEUE_DB_CHANGED') {
    try {
        const data = await getActionsFromQueue();
        

        let dbChanged, dbData:Array<queueData> = baseQueueData

        if(data == undefined || data.length == 0){
          dbChanged = false
        }else{
          dbChanged = true
          dbData = data
        }

        event.source.postMessage({
          type: 'QUEUE_DB_CHANGED',
          payload: {
            dbChanged: dbChanged,
            dbData: dbData
          }
        });
        
    } catch (error) {
        console.error("Error retrieving data:", error);
    }
  }

  if (event.source && event.data && event.data.type === 'ONLINE_DB_SHOW') {
      const data = await getActionsFromQueue();
      const cacheNames = ['books', 'user-books'];
      let queueStatusArray = [];
      let queueError = false;
      await sleep(4000);
      for (const action of data) {
          event.source.postMessage({
              type: 'ACTION_EXECUTING',
              payload: {
                  queueAction: action
              }
          });

          try {
              let response;
              const headers = {
                  'Content-Type': 'application/json',
                  
              }

              const requestOptions = {
                  method: 'POST',
                  headers: headers,
                  credentials: 'include' as RequestCredentials,
                  body: JSON.stringify({ id: action.queue_details.item_id }),
                  
              };

          
              let url = process.env.REACT_APP_BACKEND_URL;
              switch (action.queue_action) {
                  case 'Return':
                      url = url + '/returnBook';
                      break;
                  case 'Borrow':
                      url = url + '/borrowBook';
                      break;
                  default:
                      console.error('Unknown action:', action.action_name);
                      continue; // Skip the current loop iteration
              }
          
              response = await fetch(url, requestOptions);
          
              if (!response.ok) {
                  throw new Error(`HTTP error! Status: ${response.status}`);
              }

              const queuestatus: queueStatus = {
                queue_name: action.queue_details.item_name,
                queue_action: action.queue_action,
                queue_status: 'Success',
                queue_error: ""
              };

              queueStatusArray.push(queuestatus);
          
              // If the POST request was successful, remove the action from the queue
              await removeActionFromQueue(action.queue_key);
              
          
          } catch (error: any) {
              console.error('Error executing action:', error);
              const queueStatus: queueStatus = {
                queue_name: action.queue_details.item_name,
                queue_action: action.queue_action,
                queue_status: 'Failed',
                queue_error: error.message
              };
              queueError = true;

              queueStatusArray.push(queueStatus);
          }

      }

      for (let name of cacheNames) {
        await caches.delete(name);
      }
      
      event.source.postMessage({
        type: 'ALL_ACTIONS_EXECUTED',
        payload: {
          queueStatus: queueStatusArray,
          queueError: queueError
        }
      });
  }
});


// Any other custom service worker logic can go here.

registerRoute(
  ({ url }) => url.pathname === process.env.REACT_APP_BACKEND_PATH + '/getUserBooks',
  new StaleWhileRevalidate({
    cacheName: 'user-books',
    plugins: [
      new ExpirationPlugin({ maxEntries: 1 }),
    ],
  })
);


registerRoute(
  ({ url }) => url.pathname === process.env.REACT_APP_BACKEND_PATH + '/getBooks',
  new StaleWhileRevalidate({
    cacheName: 'books',
    plugins: [
      new ExpirationPlugin({ maxEntries: 1 }),
    ],
  })
);


registerRoute(
  ({ url }) => url.pathname === process.env.REACT_APP_BACKEND_PATH + '/getBook',
  new StaleWhileRevalidate({
    cacheName: 'book-details',
    plugins: [
      new ExpirationPlugin({ maxEntries: 50 }), // or however many you deem suitable
    ],
  })
);


registerRoute(
  ({ url }) => url.pathname === process.env.REACT_APP_BACKEND_PATH + '/getBorrowedBook',
  new StaleWhileRevalidate({
    cacheName: 'borrowed-book-details',
    plugins: [
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);


/* Cache for the image data for each books */
registerRoute(
  ({ url }) => url.pathname.startsWith(String(process.env.REACT_APP_BACKEND_IMAGE_PATH || "/backend/storage")) && /\.(png|jpg)$/.test(url.pathname),
  new StaleWhileRevalidate({
    cacheName: 'book-covers',
    plugins: [
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);


function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
